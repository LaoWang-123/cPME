% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/registration_class.R
\docType{class}
\name{Registration}
\alias{Registration}
\title{Registration Class for cPME Algorithm}
\format{
An \code{R6Class} generator object
}
\description{
Registration Class for cPME Algorithm

Registration Class for cPME Algorithm
}
\details{
This class implements the surface registration algorithm used in cPME.
It supports:
- building basis functions
- computing tangent updates
- iterative optimization
- saving state to RDS
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{f1}}{Function f1(u, v). The target surface embedding or image.}

\item{\code{f2}}{Function f2(u, v). The source surface to be warped.}

\item{\code{f2_grad_fn}}{Gradient of f2, a function returning (df/du, df/dv).}

\item{\code{basis_set}}{A list of basis functions used to build the tangent basis.}

\item{\code{Ugrid}}{A data frame of (u, v) evaluation points on [0,1]^2.}

\item{\code{bi_set}}{Precomputed basis functions b_i(u,v).}

\item{\code{D_bi_set}}{Precomputed gradients Db_i(u,v).}

\item{\code{gamma_k}}{Current reparameterization map γ_k(u,v).}

\item{\code{f2_k}}{Current warped surface f2 ∘ γ_k.}

\item{\code{grad_f2k_fun}}{Current gradient ∇(f2 ∘ γ_k).}

\item{\code{dgamma_coefs}}{Coefficients α_i in δγ = Σ α_i b_i.}

\item{\code{delta_gamma_fn}}{Function δγ_k(u,v).}

\item{\code{Ddelta_gamma_fn}}{Jacobian of δγ_k(u,v).}

\item{\code{state_list}}{List storing all iteration states (γ_k, α_k, E_k).}

\item{\code{E_history}}{Numeric vector storing energy values E_k.}

\item{\code{iter}}{Current iteration index.}

\item{\code{eps_step}}{Step size for γ update.}

\item{\code{eps_energy}}{Convergence threshold on |E_k - E_{k-1}|.}

\item{\code{max_iter}}{Maximum number of iterations.}

\item{\code{folder}}{Optional folder path for autosaving state.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-Registration-new}{\code{Registration$new()}}
\item \href{#method-Registration-initialize_state}{\code{Registration$initialize_state()}}
\item \href{#method-Registration-step}{\code{Registration$step()}}
\item \href{#method-Registration-run}{\code{Registration$run()}}
\item \href{#method-Registration-continue}{\code{Registration$continue()}}
\item \href{#method-Registration-save_state}{\code{Registration$save_state()}}
\item \href{#method-Registration-clone}{\code{Registration$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Registration-new"></a>}}
\if{latex}{\out{\hypertarget{method-Registration-new}{}}}
\subsection{Method \code{new()}}{
Initialization of the registration object.
Sets user-provided surfaces, gradients, basis functions, and algorithm
hyperparameters. Precomputes basis fields and initializes γ_0 and f2_0.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Registration$new(
  f1,
  f2,
  f2_grad_fn,
  basis_set,
  Ugrid,
  eps_step = 0.05,
  eps_energy = 1e-05,
  max_iter = 100,
  folder = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{f1}}{Function f1(u,v), target surface.}

\item{\code{f2}}{Function f2(u,v), source surface.}

\item{\code{f2_grad_fn}}{Gradient function of f2.}

\item{\code{basis_set}}{A list of basis functions.}

\item{\code{Ugrid}}{Data frame of (u,v) sample locations.}

\item{\code{eps_step}}{Numeric. Step size for updates.}

\item{\code{eps_energy}}{Numeric. Convergence threshold.}

\item{\code{max_iter}}{Maximum number of iterations.}

\item{\code{folder}}{Folder for autosave (optional).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The initialized Registration object (invisibly).
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Registration-initialize_state"></a>}}
\if{latex}{\out{\hypertarget{method-Registration-initialize_state}{}}}
\subsection{Method \code{initialize_state()}}{
Initialize iteration state for k = 0.
Builds γ_0, f2_0, initial basis derivatives, α coefficients,
and stores the first state.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Registration$initialize_state()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Nothing. Updates internal fields.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Registration-step"></a>}}
\if{latex}{\out{\hypertarget{method-Registration-step}{}}}
\subsection{Method \code{step()}}{
Perform ONE gradient-descent update step.
Updates γ_{k+1}, f2_{k+1}, computes energy, convergence check,
recomputes basis derivatives and coefficients.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Registration$step()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
The current energy E_k (invisibly).
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Registration-run"></a>}}
\if{latex}{\out{\hypertarget{method-Registration-run}{}}}
\subsection{Method \code{run()}}{
Run the full optimization loop up to `max_iter`.
Automatically stops if the energy change falls below `eps_energy`.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Registration$run()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Nothing. Updates the entire optimization history.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Registration-continue"></a>}}
\if{latex}{\out{\hypertarget{method-Registration-continue}{}}}
\subsection{Method \code{continue()}}{
Continue optimization from a previously saved state.
Allows overriding step size, schedule, energy threshold, etc.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Registration$continue(
  n_steps = NULL,
  max_iter_total = NULL,
  eps_step = NULL,
  eps_energy = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{n_steps}}{Number of additional steps to run (optional).}

\item{\code{max_iter_total}}{Absolute iteration target (optional).}

\item{\code{eps_step}}{Optional override of step size.}

\item{\code{eps_energy}}{Optional new convergence tolerance.}

\item{\code{step_schedule}}{Optional new step schedule.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Nothing. Continues modifying the registration state.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Registration-save_state"></a>}}
\if{latex}{\out{\hypertarget{method-Registration-save_state}{}}}
\subsection{Method \code{save_state()}}{
Save the full registration object into an RDS file.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Registration$save_state()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Nothing. Writes `reg_state.rds` to `self$folder`.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Registration-clone"></a>}}
\if{latex}{\out{\hypertarget{method-Registration-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Registration$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
